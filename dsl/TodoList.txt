Problems:

Tuples
- How can tuples be reduced? Tuples are case classes with fields.
Would have to generate classes that extend them and implement special
serialization for these classes.

Either:
class Tuple2_Int_String_1(val x : Int) extends Tuple2[Int, String](x, null)

class Tuple2_Int_String_1(val x : Int) extends Tuple2[Int, String](x, null)
kryo.register(Tuple2_Int_String_1.class, new SimpleSerializer<Tuple2_Int_String_1>() {
        public void write (ByteBuffer buffer, Tuple2_Int_String_1 tuple) {
                buffer.putInt(color._1);
        }
        public Tuple2_Int_String_1 read (ByteBuffer buffer) {
                return new Tuple2_Int_String_1(buffer.getInt());
        }
});

=> Requires:
- Serialization implementation for all backends for narrowed tuples
- Default value per type: null for reference types, 0 for numbers?
- Tuple Type generation with right names and types (no problem)

OR:
An ugly hack, meaning that tuples will always use all their fields

Decisions to take:
- Tuples => Unimportant for now, leave as is

TODO List:
- Refine finding of locations for inserting narrowing vectormaps.
	- Check all nodes which preserve types but do not want a narrowing themselves (flatten, filter, not cache).
	- If the input is a map, don't insert one. The map has either been narrowed or doesn't need it.
	- If the input is a filter, check if the filter adds field reads. Continue looking for inputs.
	- If the input is a flatmap, insert one? FlatMaps are not handled by our scheme.
	- if its GBK or reduce????? => GBK wants a narrower itself, abort. Reduce may add field reads, but also changes types.
	- if its flatten? Go on, until a stop node is found on each one. Maybe insert narrowing before flatten instead of after, if only one type changes.
- Find benchmarks and implement them => Flushes out bugs.
- Saving of nested tuples does not return all elements yet within
	- creates problem in other cases as well
- Unit Tests. 
	- Field analysis & narrowing
	- Transformers & dependency pulling 
	- Tests that check if the generated code compiles.
- Compile external source files, like delite
- ReduceToOne

Would be nice:
- merge filters
- Get Spark build running (wait for 0.12 sbt?)
- Convert this file to markdown?


Easy, low priority tasks:
- Add Tuple3, 4 etc
- Extend String class with more methods (startsWith, endsWith, contains etc)
- Spark reduce by key optimization: Allow if all readers of group by key are reduces
- Refactor field reads to use a list as representation instead of the string
- Make list of all keys in use in the metaInfos of a VectorNode 

To ask tiark:
- Compile external source files? => Investigate self first.
